PARSER_BEGIN(Parser)


/** ID lister. */
package parser;

import ast.*;
import ast.int_nodes.*;
import ast.bool_nodes.*;
import java.util.*;
import utils.*;
import ast.types.*;

public class Parser {

}


PARSER_END(Parser)


TOKEN:
{
	< LET : "let" >
	| < TRUE : "true" >
	| < FALSE: "false" >
	| < Num: (["0"-"9"]) + >
	| < PLUS : "+" >
	| < MINUS : "-">
	| < TIMES : "*">
	| < DIV : "/">
	| < OR : "||">
	| < AND : "&&">
	| < NOT : "!">
	| < LTE : "<=" >
	| < LT : "<" >
	| < GTE : ">=" >
	| < GT : ">" >
	| < EQ : "==">
	| < DIFF : "!=">
	| < LPAR : "(" >
	| < RPAR : ")" >
	| < LCURLY : "{" >
	| < RCURLY : "}" >
	| < EQUALS : "=" >
	| < DOTCOMMA : ";" >
	| < COMMA : "," >
	| < TWODOTS : ":" >
	| < FUN : "fn" >
	| < STR: "String" >
	| < BOOL: "Bool" >
	| < ARROW: "->" >
	| < Id: ["a"-"z","A"-"Z"] ( ["a"-"z","A"-"Z","0"-"9"] )* >	
}


SKIP:
{
		" "
	| "\t"
	| "\n"
	| "\r"
}


ASTNode Start():
{
	ASTNode t; 
}
{
	t = Exp() <DOTCOMMA>
	{ return t; }
}

ASTNode Exp() :
{
    ASTNode t1, t2;
}
{
    t1 = OrChain() (
       <AND> t2 = Exp()
       {
            t1 = new ASTAnd(t1, t2);
       }
   ) ?
   {
       return t1;
   }
}

ASTNode OrChain():
{
    ASTNode t1, t2;
}
{
    t1 = BoolTerm() (
        <OR> t2 = OrChain()
        {
            t1 = new ASTOr(t1, t2);
        }
    ) ?
    {
        return t1;
    }
}

ASTNode BoolTerm():
{
    Token op;
    ASTNode t1, t2;
}
{
    <NOT> t1 = NumExp()
    {
        t1 = new ASTNot(t1);
    }
    | t1 = NumExp()
    (
       (op = <LT>
       | op = <LTE>
       | op = <GT>
       | op = <GTE>
       | op = <EQ>
       | op = <DIFF>)
    t2 = NumExp()
        {
            switch(op.kind){
                case LT:
                    t1 = new ASTLowerThan(t1, t2);
                    break;
                case LTE:
                    t1 = new ASTLowerOrEqual(t1, t2);
                    break;
                case GT:
                    t1 = new ASTGreaterThan(t1, t2);
                    break;
                case GTE:
                    t1 = new ASTGreaterOrEqual(t1, t2);
                    break;
                case EQ:
                    t1 = new ASTEqual(t1, t2);
                    break;
                case DIFF:
                    t1 = new ASTNotEqual(t1, t2);
                    break;
                default:
                    throw new RuntimeException("Unexpected token");
            }
        }
    )?
    {
        return t1;
    }
}

ASTNode NumExp():
{ 
  Token op;
  ASTNode t1, t2;
}
{
  t1 = Term() (( op = <PLUS> | op = <MINUS> ) t2 = Term() 
    {
  if (op.kind == PLUS) {
    t1 = new ASTPlus(t1, t2);
  }
  else t1 = new ASTMinus(t1, t2);
}
  ) *
  { return t1; }
}

ASTNode Term():
{
	Token op;
	ASTNode t1, t2;
}
{
  t1 = Fact() (( op = <TIMES> | op = <DIV> ) t2 = Term() 
  {
  if (op.kind == TIMES) {
    t1 = new ASTTimes(t1, t2);
  }
  else t1 = new ASTDiv(t1, t2);
}) ?
  { return t1; }
}


ASTNode Fact():
{ 
  Token n;
  ASTNode t;
  Token id;
}
{
		<TRUE> { return new ASTBool(true); }
	| <FALSE> { return new ASTBool(false); }

	| <MINUS> t = Fact()
		{
			t = new ASTNeg(t);
			return t;
		}

	| n = <Num>
		{
			t = new ASTNum(Integer.parseInt(n.image));
			return t;
		}

	| <LPAR> t = Exp() <RPAR>
		{
			return t;
		}

	| LOOKAHEAD(2) id = <Id> <LPAR> 
		{
			ArrayList<ASTNode> params = new ArrayList(); 	
			ASTNode param;
		}

		( param = Exp() { params.add(param); } ) ?  
		( <COMMA> param = Exp() { params.add(param); } ) *

	    <RPAR> <DOTCOMMA>

	    { return new ASTFunctionApplication(id.image, params); }

	| id = <Id>
		{
			return new ASTId(id.image);
		}

	| <LCURLY>
		{
			HashMap<String, ASTNode> l = new HashMap<>();
			ASTNode b;
		}

		(
			<LET> (id = <Id>) <EQUALS> (t = Exp()) <DOTCOMMA>
			{
				l.put(id.image, t);
			}
		) *

		(b = Exp())
		<RCURLY>
		{
			return new ASTDef(b, l);
		}

	| <FUN> <LPAR> 
		{
			HashMap<String, ASTNode> d = new HashMap<>(); 
			ArrayList<Pair<String, String>> p = new ArrayList<>(); 
			ASTNode b;
			Token type;
			Token retType = null;
		}

		(
			id = <Id> <TWODOTS> type = <Id> {
				p.add(new Pair(id.image, type.image));
			} 
			
			(<COMMA> id = <Id> <TWODOTS> type = <Id> {
				p.add(new Pair(id.image, type.image));
			}) *
		) ?

		<RPAR> <ARROW> retType = <Id> <LCURLY>

		(
			<LET> (id = <Id>) <EQUALS> (t = Exp()) <DOTCOMMA>
			{
				d.put(id.image, t);
			}
		) *

		( b = Exp() )

        <RCURLY>

		{
			return new ASTFunction(b, p, d, retType != null ? new ValueType(Type.valueOf(retType.image)) : null);
		}

}
